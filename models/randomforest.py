# -*- coding: utf-8 -*-
"""randomforest.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18O_jKAsW6fKT_1mvwoG6yrARnk177VkJ
"""

# -*- coding: utf-8 -*-
"""rf_only_sales_prediction.ipynb"""

## 데이터 전처리 및 특징 변수 생성

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import OneHotEncoder
from sklearn.metrics import mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt
import matplotlib.font_manager as fm
import warnings
warnings.filterwarnings('ignore')
from google.colab import drive
drive.mount('/content/drive')

# 한글 폰트 설정 (기존 코드와 동일)
font_path = '/content/drive/MyDrive/SeoulNamsanC.otf'
font_prop = fm.FontProperties(fname=font_path)
plt.style.use('dark_background')

# 2.1. 데이터 로딩 및 초기 정제
train_df_raw = pd.read_csv('/content/drive/MyDrive/lgaimers/train_split.csv')
test_df_raw = pd.read_csv('/content/drive/MyDrive/lgaimers/filtered_TEST_00.csv')

# 예측 대상 영업장 및 메뉴 필터링
train_bbq_df = train_df_raw[train_df_raw['영업장명'] == '느티나무 셀프BBQ']
target_menu = '1인 수저세트'
target_df_train = train_bbq_df[train_bbq_df['메뉴명'] == target_menu]
test_df_target = test_df_raw[test_df_raw['영업장명_메뉴명'] == '느티나무 셀프BBQ_1인 수저세트'].copy()

# 2.2. Random Forest 모델을 위한 특징 변수 생성
def create_rf_features(df):
    df['영업일자'] = pd.to_datetime(df['영업일자'])
    df['요일'] = df['영업일자'].dt.day_name()
    # 전날 매출량 변수 생성. 결측값은 뒤에서부터 채움.
    df['lag_1'] = df['매출수량'].shift(1).fillna(method='bfill')
    return df

target_df_train = create_rf_features(target_df_train.copy())
test_df_target = create_rf_features(test_df_target.copy())

# 2.3. 원-핫 인코딩
ohe = OneHotEncoder(handle_unknown='ignore', sparse_output=False)
ohe.fit(target_df_train[['요일']])

def transform_rf_features(df, ohe_encoder):
    df_encoded = pd.DataFrame(ohe_encoder.transform(df[['요일']]), columns=ohe_encoder.get_feature_names_out(['요일']))
    X = pd.concat([df_encoded.reset_index(drop=True), df['lag_1'].reset_index(drop=True)], axis=1)
    return X

# 훈련 데이터셋 생성
X_train = transform_rf_features(target_df_train, ohe)
y_train = target_df_train['매출수량']

# 테스트 데이터셋 생성
# 테스트 데이터의 매출수량(y_test)은 예측 대상이므로, lag_1 변수를 처리할 때 훈련 데이터의 마지막 값으로 시작해야 함
last_train_value = target_df_train['매출수량'].iloc[-1]
test_df_target['lag_1'] = np.concatenate([[last_train_value], test_df_target['매출수량'].shift(1).iloc[1:].values])
# 평가를 위해 실제 테스트 데이터의 매출수량은 별도로 저장
y_test_actual = test_df_target['매출수량']
# 예측에 사용할 테스트 데이터 특징 변수 생성 (매출수량 제외)
X_test = transform_rf_features(test_df_target, ohe)

print("훈련 데이터 특징 변수(X_train) 5행:")
print(X_train.head())
print("\n테스트 데이터 특징 변수(X_test) 5행:")
print(X_test.head())

## Random Forest 모델 학습 및 예측

# 모델 학습
# 기존 코드에서 사용된 하이퍼파라미터로 모델을 정의합니다.
rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
rf_model.fit(X_train, y_train)

# 예측 수행
y_hat_rf = rf_model.predict(X_test)
# 예측값이 음수인 경우 0으로 처리
y_hat_rf[y_hat_rf < 0] = 0

## 모델 성능 평가

def calculate_metrics(y_true, y_pred):
    mae = mean_absolute_error(y_true, y_pred)
    rmse = np.sqrt(mean_squared_error(y_true, y_pred))
    smape = np.mean(2 * np.abs(y_pred - y_true) / (np.abs(y_true) + np.abs(y_pred))) * 100
    return mae, rmse, smape

mae_rf, rmse_rf, smape_rf = calculate_metrics(y_test_actual, y_hat_rf)

print("\n\nRandom Forest 단독 모델 예측 성능 지표")
print(f"MAE: {mae_rf:.2f}")
print(f"RMSE: {rmse_rf:.2f}")
print(f"SMAPE: {smape_rf:.2f}%")

## '1인 수저세트' 매출 예측 시계열 그래프

plt.figure(figsize=(15, 8))
plt.plot(test_df_target['영업일자'], y_test_actual, label='Actual Sales', marker='o', color='white', linestyle='--')
plt.plot(test_df_target['영업일자'], y_hat_rf, label='Random Forest Only Forecast', marker='^', color='orange', linestyle='-')
plt.title('느티나무 셀프BBQ \'1인 수저세트\' Random Forest 단독 예측 결과', fontsize=16, fontproperties=font_prop)
plt.xlabel('Date', fontsize=12)
plt.ylabel('Sales Quantity', fontsize=12)
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show();

"""## random forest X 2"""

# rf_hybrid_with_postprocess.py

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import RandomizedSearchCV
from sklearn.preprocessing import OneHotEncoder
from sklearn.metrics import mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt
from google.colab import drive
drive.mount('/content/drive')

import matplotlib.font_manager as fm
font_path = '/content/drive/MyDrive/SeoulNamsanC.otf'
font_prop = fm.FontProperties(fname=font_path)

import matplotlib
matplotlib.rcParams['font.family'] = 'sans-serif'  # 또는 'Malgun Gothic', 'AppleGothic' 등 시스템에 있는 한글 폰트
plt.style.use('dark_background') # matplotlib 다크모드 설정
# 1. 데이터 로딩
train_df_raw = pd.read_csv('/content/drive/MyDrive/lgaimers/train_split.csv')
test_df_raw = pd.read_csv('/content/drive/MyDrive/lgaimers/TEST_00.csv')

# 2. 예측 대상 및 보조 메뉴 필터링
target_menu = '1인 수저세트'
auxiliary_menus = ['BBQ55(단체)', '대여료 30,000원']
all_relevant_menus = [target_menu] + auxiliary_menus

train_bbq_df = train_df_raw[train_df_raw['영업장명'] == '느티나무 셀프BBQ']
target_df_train = train_bbq_df[train_bbq_df['메뉴명'] == target_menu]
aux_df_train_bbq55 = train_bbq_df[train_bbq_df['메뉴명'] == 'BBQ55(단체)']
aux_df_train_rental30k = train_bbq_df[train_bbq_df['메뉴명'] == '대여료 30,000원']

# 3. 특징 변수 생성 함수
def create_rf_features(df):
    df = df.copy()
    df['영업일자'] = pd.to_datetime(df['영업일자'])
    df['월'] = df['영업일자'].dt.month
    df['요일'] = df['영업일자'].dt.day_name()
    df['lag_1'] = df['매출수량'].shift(1).fillna(method='bfill')
    return df

target_df_train = create_rf_features(target_df_train)
aux_df_train_bbq55 = create_rf_features(aux_df_train_bbq55)
aux_df_train_rental30k = create_rf_features(aux_df_train_rental30k)

# 4. 원-핫 인코더 학습 (요일)
ohe = OneHotEncoder(handle_unknown='ignore', sparse_output=False)
ohe.fit(target_df_train[['요일']])

def transform_rf_features(df):
    df_encoded = pd.DataFrame(ohe.transform(df[['요일']]), columns=ohe.get_feature_names_out(['요일']))
    X = pd.concat([
        df_encoded.reset_index(drop=True),
        pd.DataFrame(df['lag_1']).reset_index(drop=True),
        pd.DataFrame(df['매출수량']).reset_index(drop=True),
        pd.DataFrame(df['월']).reset_index(drop=True)
    ], axis=1)
    return X

def transform_rf_features_test(df):
    df_encoded = pd.DataFrame(ohe.transform(df[['요일']]), columns=ohe.get_feature_names_out(['요일']))
    if '월' not in df.columns:
        df['월'] = df['ds'].dt.month
    X = pd.concat([
        df_encoded.reset_index(drop=True),
        pd.DataFrame(df['lag_1']).reset_index(drop=True),
        pd.DataFrame(df['매출수량']).reset_index(drop=True),
        pd.DataFrame(df['월']).reset_index(drop=True)
    ], axis=1)
    return X

# 5. 1차 RandomForest 모델 학습 (매출수량 직접 예측)
X_train_1 = transform_rf_features(target_df_train)
y_train_1 = target_df_train['매출수량']

rf1 = RandomForestRegressor(n_estimators=100, random_state=42)
rf1.fit(X_train_1, y_train_1)

# 6. 2차 RandomForest 모델 학습 (잔차 예측)
y_pred_train_1 = rf1.predict(X_train_1)
residuals_train_2 = y_train_1 - y_pred_train_1

X_train_2 = X_train_1.copy()
rf2 = RandomForestRegressor(n_estimators=100, random_state=42)
rf2.fit(X_train_2, residuals_train_2)

# 7. 테스트 데이터 특징 생성
test_dates = pd.to_datetime(test_df_raw['영업일자'].unique())
future = pd.DataFrame({'ds': test_dates})
future['요일'] = future['ds'].dt.day_name()
future['월'] = future['ds'].dt.month

# lag_1 생성: [train 마지막 값, 예측값[:-1]]
last_train_value = target_df_train['매출수량'].iloc[-1]
# 1차 예측값 rolling 생성
lag_1 = [last_train_value]
X_test_1 = []
for i in range(len(future)):
    row = future.iloc[i].copy()
    row['lag_1'] = lag_1[-1]
    row_df = pd.DataFrame([row])
    row_df['매출수량'] = 0  # 예측 시 실제값 모름
    X_row = transform_rf_features_test(row_df)
    y_pred_1 = rf1.predict(X_row)[0]
    lag_1.append(y_pred_1)
    X_test_1.append(X_row.values[0])
X_test_1 = np.array(X_test_1)
y_pred_test_1 = rf1.predict(X_test_1)

# 2차 예측(잔차)
y_pred_test_2 = rf2.predict(X_test_1)
y_hat_base_test = y_pred_test_1 + y_pred_test_2

# 8. 보조 메뉴 예측 및 후처리 adjustment_factor 계산
def predict_aux_rf(aux_df_train, test_dates):
    aux_df_train = create_rf_features(aux_df_train)
    X_aux_train = transform_rf_features(aux_df_train)
    y_aux_train = aux_df_train['매출수량']
    rf_aux = RandomForestRegressor(n_estimators=100, random_state=42)
    rf_aux.fit(X_aux_train, y_aux_train)
    # lag_1 rolling
    last_aux = y_aux_train.iloc[-1] if len(y_aux_train) > 0 else 0
    lag_1 = [last_aux]
    X_aux_test = []
    for i in range(len(test_dates)):
        row = {'ds': test_dates[i], '요일': test_dates[i].day_name(), '월': test_dates[i].month, 'lag_1': lag_1[-1], '매출수량': 0}
        row_df = pd.DataFrame([row])
        X_row = transform_rf_features_test(row_df)
        y_pred = rf_aux.predict(X_row)[0]
        lag_1.append(y_pred)
        X_aux_test.append(X_row.values[0])
    X_aux_test = np.array(X_aux_test)
    y_hat_aux = rf_aux.predict(X_aux_test)
    avg_aux = y_aux_train.mean() if len(y_aux_train) > 0 else 1
    return y_hat_aux, avg_aux

y_hat_bbq55, avg_bbq55 = predict_aux_rf(aux_df_train_bbq55, test_dates)
y_hat_rental30k, avg_rental30k = predict_aux_rf(aux_df_train_rental30k, test_dates)

corr_bbq55 = 0.85
corr_rental30k = 0.72
adjustment_factor = ((y_hat_bbq55 / avg_bbq55) - 1) * corr_bbq55 + ((y_hat_rental30k / avg_rental30k) - 1) * corr_rental30k
adjustment_factor = np.clip(adjustment_factor, -0.9, 2.0)  # 극단적 조정 방지

# 9. 후처리 적용
# y_hat_final_test = y_hat_base_test * (1 + adjustment_factor)
y_hat_final_test = y_hat_base_test
y_hat_final_test[y_hat_final_test < 0] = 0

# 10. 실제값 및 평가
test_df = test_df_raw[test_df_raw['영업장명_메뉴명'] == '느티나무 셀프BBQ_1인 수저세트'].copy()
y_actual_test = test_df['매출수량'].values
test_dates_df = pd.DataFrame({'ds': pd.to_datetime(test_df['영업일자'])})

def calculate_metrics(y_true, y_pred):
    mae = mean_absolute_error(y_true, y_pred)
    rmse = np.sqrt(mean_squared_error(y_true, y_pred))
    smape = np.mean(2 * np.abs(y_pred - y_true) / (np.abs(y_true) + np.abs(y_pred))) * 100
    return mae, rmse, smape

mae_base, rmse_base, smape_base = calculate_metrics(y_actual_test, y_hat_base_test)
mae_final, rmse_final, smape_final = calculate_metrics(y_actual_test, y_hat_final_test)

metrics_df = pd.DataFrame({
    'Model': ['rf_base', 'rf_final'],
    'MAE': [mae_base, mae_final],
    'RMSE': [rmse_base, rmse_final],
    'SMAPE (%)': [smape_base, smape_final]
})
print("\n\n모델별 예측 성능 지표 비교")
print(metrics_df)

# 11. 시계열 그래프
plt.figure(figsize=(15, 8))
plt.plot(test_dates, y_actual_test, label='Actual Sales', marker='o', color='white', linestyle='--')
plt.plot(test_dates, y_hat_base_test, label='RF Base Forecast', marker='s', color='orange', linestyle='-.')
plt.plot(test_dates, y_hat_final_test, label='Final Forecast (Post-processed)', marker='^', color='green', linestyle='-')
plt.title("느티나무 셀프BBQ '1인 수저세트' RF+후처리 예측 결과 비교", fontsize=16, fontproperties=font_prop)
plt.xlabel('Date', fontsize=12)
plt.ylabel('Sales Quantity', fontsize=12)
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show();

print("훈련 데이터 매출수량 분포:", target_df_train['매출수량'].describe())
print("테스트 데이터 lag_1 값:", test_df_raw['매출수량'].shift(1).fillna(method='bfill').head())
print("y_hat_base_test:", y_hat_base_test[:10])
print("adjustment_factor:", adjustment_factor[:10])
print("y_hat_final_test:", y_hat_final_test[:10])

y_pred_train_1 = rf1.predict(X_train_1)
print(y_pred_train_1[:20])